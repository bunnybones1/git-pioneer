var pointOnSphere = require("utils/math/point-on-sphere-fibonacci");
var triangulate = require("delaunay-triangulate");
var three = require("three");

function SphereGeometry(radius, total, elongatedTarget){
	radius = radius !== undefined ? radius : 20;
	total = total !== undefined ? total : 20;
	var verticeArrays = [];
	var geometry = new three.Geometry();
	var vertices = geometry.vertices;
	var i, hash, uniqueIndex;
	for (i = 0; i < total; i++) {
		var longLat = pointOnSphere(i, total);
		var long = longLat[0];
		var lat = longLat[1];
		var vertArr = [
			Math.cos(lat) * Math.cos(long) * radius,
			Math.sin(lat) * radius,
			Math.cos(lat) * Math.sin(long) * radius
		];
		verticeArrays.push(vertArr);
		vertices.push((new three.Vector3().fromArray(vertArr)));
	}
	var tetras = triangulate(verticeArrays);
	var triangles = [];
	for (i = 0; i < tetras.length; i++) {
		var tetra = tetras[i];
		triangles.push(tetra[0], tetra[1], tetra[3]);
		triangles.push(tetra[0], tetra[2], tetra[1]);
		triangles.push(tetra[0], tetra[3], tetra[2]);
		triangles.push(tetra[3], tetra[1], tetra[2]);
	}

	var uniques = [];
	var counts = [];
	var tempTri = [];
	function uniqueTriOrderSort(a, b) {
		return a - b;
	}
	for (i = 0; i < triangles.length; i+=3) {
		tempTri[0] = triangles[i];
		tempTri[1] = triangles[i+1];
		tempTri[2] = triangles[i+2];
		tempTri = tempTri.sort(uniqueTriOrderSort);
		hash = tempTri[0]+","+tempTri[1]+","+tempTri[2];
		uniqueIndex = uniques.indexOf(hash);
		if(uniqueIndex === -1) {
			uniqueIndex = uniques.length;
			uniques.push(hash);
			counts.push(0);
		}
		counts[uniqueIndex]++;
	}
	for (i = 0; i < triangles.length; i+=3) {
		tempTri[0] = triangles[i];
		tempTri[1] = triangles[i+1];
		tempTri[2] = triangles[i+2];
		tempTri = tempTri.sort(uniqueTriOrderSort);
		hash = tempTri[0]+","+tempTri[1]+","+tempTri[2];
		uniqueIndex = uniques.indexOf(hash);
		if(counts[uniqueIndex] === 1) {
			var face = new three.Face3(triangles[i], triangles[i+1], triangles[i+2]);
			geometry.faces.push(face);
		}
	}
	geometry.computeFaceNormals();
	geometry.computeVertexNormals();
	// geometry.computeTangents();

	if(elongatedTarget) {
		var vertices2 = [];
		geometry.vertices.forEach(function(v){
			if(v.y>0) {
				v.multiplyScalar(0.8);
				v.y += 1;
			}
			var v2 = v.clone();
			if(v2.y<0) {
				v2.y = 0;
			}else{
				v2.y = 1;
			}
			vertices2.push(v2);
		});
		geometry.morphTargets.push( { name: "target", vertices: vertices2 } );
	}

	return geometry;
}

module.exports = SphereGeometry;