var three = require("three");
var cannon = require("cannon");

three.Vector3.prototype.toCannon = function toCannon() {
	return new cannon.Vec3(this.x, this.y, this.z);
};

cannon.Vec3.prototype.toThree = function toThree() {
	return new three.Vector3(this.x, this.y, this.z);
};

three.Quaternion.prototype.toCannon = function toCannon() {
	return new cannon.Quaternion(this.x, this.y, this.z, this.w);
};

cannon.Quaternion.prototype.toThree = function toThree() {
	return new three.Quaternion(this.x, this.y, this.z, this.w);
};

cannon.Body.prototype.lookAt = function () {

	var m1 = new three.Matrix4();
	var vector = new three.Vector3();
	var up = new three.Vector3(0, 0, 1);

	return function lookAt(vec) {
		vector.copy( vec );
		m1.lookAt( this.position, vector, up );
		// debugger;
		this.quaternion.setFromRotationMatrix( m1 );
	};
}();

cannon.Quaternion.prototype.setFromRotationMatrix = function ( m ) {

	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	var te = m.elements,

		m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
		m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
		m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

		trace = m11 + m22 + m33,
		s;

	if ( trace > 0 ) {

		s = 0.5 / Math.sqrt( trace + 1.0 );

		this.w = 0.25 / s;
		this.x = ( m32 - m23 ) * s;
		this.y = ( m13 - m31 ) * s;
		this.z = ( m21 - m12 ) * s;

	} else if ( m11 > m22 && m11 > m33 ) {

		s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

		this.w = ( m32 - m23 ) / s;
		this.x = 0.25 * s;
		this.y = ( m12 + m21 ) / s;
		this.z = ( m13 + m31 ) / s;

	} else if ( m22 > m33 ) {

		s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

		this.w = ( m13 - m31 ) / s;
		this.x = ( m12 + m21 ) / s;
		this.y = 0.25 * s;
		this.z = ( m23 + m32 ) / s;

	} else {

		s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

		this.w = ( m21 - m12 ) / s;
		this.x = ( m13 + m31 ) / s;
		this.y = ( m23 + m32 ) / s;
		this.z = 0.25 * s;

	}
};

