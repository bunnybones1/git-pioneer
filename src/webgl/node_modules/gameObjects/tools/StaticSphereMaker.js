var three = require("three");
var cannon = require("cannon");

var geomLib = require("geometry/lib");
var matLib = require("materials/lib");
var BaseGun = require("./BaseGun");
var decorateMethodBefore = require("utils/decorateMethodBefore");
var CollisionLayers = require("CollisionLayers");

function StaticMaker(pos) {
	var geometry = geomLib.gunBase(0.035, 0.165, 1, 16, 1);
	var material = matLib.checkerboards();
	BaseGun.call(this, pos, geometry, material);
	this.primaryFireStart = primaryFireStart.bind(this);
	this.primaryFireEnd = primaryFireEnd.bind(this);
	this.onCannonPostStep = onCannonPostStep.bind(this);
	decorateMethodBefore(this, "onEnterFrameEquipped", onEnterFrame.bind(this));
}

StaticMaker.prototype = Object.create(BaseGun.prototype);

var relative = new three.Vector3();
var result = new cannon.RaycastResult();
function primaryFireStart(pos, playerSize) {
	var from = new three.Vector3();
	var to = new three.Vector3();
	relative.subVectors(this.player.user.crosshair.localToWorld(to), this.player.user.camera.localToWorld(from));
	relative.multiplyScalar(100);
	to.add(relative);

	this.player.world.physics.raycastClosest(from, to, {
		skipBackfaces: true,
		collisionFilterMask: CollisionLayers.ENVIRONMENT
	}, result);
	if(result.hasHit) {
		if(result.body.type == cannon.Body.STATIC) {
			this.player.world.makeHitEffect(result.hitPointWorld, playerSize * 0.3, 0.2);

			var grappleBody = new cannon.Body({
				type: cannon.Body.STATIC,
				position: this.player.user.crosshair.worldToLocal(new three.Vector3()).toCannon(), // m 
			});
			this.player.world.physics.addBody(grappleBody);

			var spring = new cannon.Spring(grappleBody, result.body, {
				restLength: 0,
				localAnchorA: new cannon.Vec3(),
				worldAnchorB: result.hitPointWorld
			});

			var geom = new three.SphereGeometry(0.5, 16, 8);
			var t = 0;
			geom.vertices.forEach(v => {
				v.y += 0.5;
				t = v.z;
				v.z = v.y;
				v.y = t;
			});
			var mat = new three.MeshBasicMaterial({
				wireframe: true
			});

			var effect = new three.Mesh(geom, mat);
			this.player.world.scene.add(effect);

			this.spring = spring;
			this.grappleBody = grappleBody;
			this.effect = effect;
			this.player.world.physics.addEventListener("postStep", this.onCannonPostStep);
			this.ball = this.player.world.makeBall(result.hitPointWorld, playerSize, undefined, true);
			this.startTime = performance.now();
		}
	}
}

function primaryFireEnd(pos, playerSize) {
	if(this.spring) {
		this.spring = null;
		this.ball = null;
		this.player.world.physics.removeEventListener("postStep", this.onCannonPostStep);
		this.player.world.physics.removeBody(this.grappleBody);
		this.effect.parent.remove(this.effect);
		this.grappleBody = null;
		this.effect = null;
	}
}

function onCannonPostStep(event) {
	this.grappleBody.position.copy(this.player.user.crosshair.localToWorld(new three.Vector3()));
	this.spring.applyForce();
}

function onEnterFrame() {
	var tool = this.player.activeTool;
	if(this.spring && tool) {
		this.effect.position.copy(tool.mesh.localToWorld(tool.nozzle.clone()));
		var target = this.spring.bodyB.pointToWorldFrame(this.spring.localAnchorB).toThree();
		this.effect.lookAt(target);
		var stretch = this.effect.position.clone().sub(target).length();
		var squash = Math.min(1, 1 / stretch);
		this.effect.scale.set(squash, squash, stretch);
		var s = (performance.now() - this.startTime) * 0.001;
		var shape = this.ball.body.shapes[0];
		shape.radius = s * 0.5;
		shape.updateBoundingSphereRadius();
		var segs = Math.max(4, Math.pow(2, Math.floor(Math.sqrt(s) + 2)));
		this.ball.mesh.geometry = geomLib.sphere(0.5, segs * 2, segs);
		this.ball.mesh.material = matLib.checkerboards(0x000000, 0xffffff, segs, segs * 0.5);
		this.ball.mesh.scale.set(s, s, s);
	}
}

module.exports = StaticMaker;