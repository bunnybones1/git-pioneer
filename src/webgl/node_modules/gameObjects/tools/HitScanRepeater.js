var three = require("three");
var cannon = require("cannon");
var geomLib = require("geometry/lib");
var BaseGun = require("./BaseGun");
var SoftNumberToggle = require("utils/SoftNumberToggle");

function HitScanRepeater(pos) {
	var geometry = geomLib.gunBase(0.065, 0.035, 1.5, 16, 1).clone();
	var curvedBar = geomLib.curvedBar();
	var s = 0.35;
	var placeMatrix = new three.Matrix4().compose(
		new three.Vector3(0, -0.52, 0.15 * s),
		new three.Quaternion(),
		new three.Vector3(s, s, s)
	);
	var nubs = 6;
	for(var i = 0; i < nubs; i++) {
		var nubMatrix = new three.Matrix4().makeRotationY(i/nubs * Math.PI * 2);
		nubMatrix.multiply(placeMatrix);
		geometry.merge(curvedBar, nubMatrix);
	}

	BaseGun.call(this, pos, geometry);
	this.triggerSpin = new SoftNumberToggle(0.25, 0.03, 0.075, 0.005);
	this.primaryFireStart = primaryFireStart.bind(this);
	this.primaryFireEnd = primaryFireEnd.bind(this);
	this.onEnterFrameEquipped = onEnterFrame.bind(this);
	this.delay = 0;
}

HitScanRepeater.prototype = Object.create(BaseGun.prototype);

var relative = new three.Vector3();
var result = new cannon.RaycastResult();
function primaryFireStart() {
	this.triggerSpin.state = true;
}
function primaryFireEnd() {
	this.triggerSpin.state = false;
}

function primaryFireShot() {
	var from = new three.Vector3();
	var to = new three.Vector3();
	relative.subVectors(this.player.user.crosshair.localToWorld(to), this.player.camera.localToWorld(from));
	relative.multiplyScalar(100);
	to.add(relative);

	this.player.world.physics.raycastClosest(from, to, {
		skipBackfaces: true
	}, result);
	if(result.hasHit) {
		this.player.world.makeHitEffect(result.hitPointWorld, this.player.playerSize * 0.3, 0.2);
		if(result.body.type == cannon.Body.DYNAMIC) {
			result.body.applyImpulse(relative, result.hitPointWorld);
		}
	}
}

var delayBetweenBullets = 1/8;

function onEnterFrame(timeScale) {
	this.triggerSpin.onEnterFrame(timeScale);
	if(this.triggerSpin.state && this.delay == 0) {
		primaryFireShot.call(this);
		this.delay += delayBetweenBullets;
	}
	this.delay = Math.max(0, this.delay - 1/60*timeScale);
	this.subMesh.position.y = this.delay;
	this.subMesh.rotation.y += this.triggerSpin.value * timeScale;
}

module.exports = HitScanRepeater;