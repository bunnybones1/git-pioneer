var signals = require("signals");
var three = require("three");
var cannon = require("cannon");
var CollisionLayers = require("CollisionLayers");
var geomLib = require("geometry/lib");
var matLib = require("materials/lib");

function Portal(pos) {
	var radius = 1.5;
	var geometry = geomLib.sphere(radius, 32, 16);
	var material = matLib.checkerboards(0xffffff*Math.random(), 0xffffff*Math.random());
	material.side = three.BackSide;
	material.colorWrite = false;

	var shape = new cannon.Sphere(radius);
	var body = new cannon.Body({
		mass: 5 * Math.pow(radius, 3), // kg 
		position: pos,
		type: cannon.Body.DYNAMIC,
		shape: shape,
		linearDamping: 0.6,
		angularDamping: 0.6,
		collisionFilterGroup: CollisionLayers.PORTALS,
		collisionFilterMask: CollisionLayers.ENVIRONMENT | CollisionLayers.PLAYER | CollisionLayers.PORTALS | CollisionLayers.ITEMS
	});
	body.resistGravity = true;

	// body.quaternion.setFromEuler(0, 0, 0);
	var mesh = new three.Mesh(
		geometry,
		material
	);

	body.interactiveObject = { type: "portal", object: this };
	var onPlayerEnterSignal = new signals.Signal();
	var onPlayerExitSignal = new signals.Signal();
	this.onPlayerEnterSignal = onPlayerEnterSignal;
	this.onPlayerExitSignal = onPlayerExitSignal;

	this.radius = radius;
	this.mesh = mesh;
	this.body = body;

	var _this = this;
	mesh.onBeforeRender = function() {
		if(_this.portalLink.stencilTime) return;
		_this.portalLink.requestAddingRenderPassOfOtherWorld(_this);
	};

	var world = null;
	Object.defineProperty(this, "world", {
		set: function(value) {
			world = value;
		},
		get: function() {
			return world;
		}
	});

	this.onUpdateSim = function onUpdateSim() {
		if(!this.portalLink || !world || !world.userHead) {
			return;
		}
		var dist = world.userHead.body.position.distanceTo(body.position);
		if(!this.portalLink.userInsidePortal && dist < radius * 0.99) {
			this.portalLink.userInsidePortal = true;
			console.log("inside " + this.name);
			var normalizedCrosshairPos = world.userHead.body.pointToLocalFrame(body.position);
			console.log(normalizedCrosshairPos);
			onPlayerEnterSignal.dispatch(this, normalizedCrosshairPos.z > 0);
		} else if(this.portalLink.userInsidePortal && dist > radius * 1.01) {
			this.portalLink.userInsidePortal = false;
			console.log("outside " + this.name);
			onPlayerExitSignal.dispatch(this);
		}
	};
}

Portal.prototype.getDeltaMatrix = function () {
	return this.portalLink.getDeltaMatrix(this);
}

module.exports = Portal;