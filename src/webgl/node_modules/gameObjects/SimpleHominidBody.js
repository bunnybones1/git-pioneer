var three = require("three");
var CANNON = require("cannon");
var Signal = require("signals").Signal;
var CollisionLayers = require("CollisionLayers");
var clamp = require("clamp");
require("extensions/array");
require("extensions/three");
var sizeSpeedStep = 0.001;

function SimpleHominidBody(scene, camera, inputManager) {
	this.playerSize = 1;
	this.sizeSpeed = 0;

	var _activeTool = null;
	var tools = [];
	Object.defineProperty(this, "activeTool", {
		get: function() {
			return _activeTool;
		},
		set: function(val) {
			if(_activeTool != null) {
				_activeTool.mesh.parent.remove(_activeTool.mesh);
				if(_activeTool.primaryFireEnd) _activeTool.primaryFireEnd();
			}
			tools.pushUnique(val);
			_activeTool = val;
			if(!_activeTool) return;
			_activeTool.player = this;
			_activeTool.onEnterFrame = _activeTool.onEnterFrameEquipped;
			handPivot.add(_activeTool.mesh);
			_activeTool.subMesh.rotation.set(0, 0, 0);
			_activeTool.mesh.rotation.set(0, 0, 0);
			_activeTool.mesh.position.set(0, 0, 0);
		}
	});
	
	var onPlayerSizeChangedSignal = new Signal();
	// camera.near = 0.001;
	// camera.far = 40;
	// camera.updateProjectionMatrix();

	var pointers = inputManager.pointers;
	var keyboard = inputManager.fpsController.keyboard;



	// bodyShape.material = groundMaterial;
	var playerBody = new CANNON.Body({
		mass: 50, // kg 
		position: new CANNON.Vec3(0, 3, 0.15), // m 
		rotation: new CANNON.Vec3(0, 1, 0), // m 
		fixedRotation: true,
		// linearDamping: 0.5,
		// resistGravity: true,
		collisionFilterGroup: CollisionLayers.PLAYER,
		collisionFilterMask: CollisionLayers.ENVIRONMENT | CollisionLayers.ITEMS
	});
	var bodySphereRecipe = [
		[0, 0, 0, 0.2],
		[0, -0.8, 0, 0.5],
		[0, -1.4, 0, 0.2]
	];
	for(var i = 0; i < bodySphereRecipe.length; i++) {
		var d = bodySphereRecipe[i];
		var shape = new CANNON.Sphere(d[3]);
		playerBody.addShape(shape, new CANNON.Vec3(d[0], d[1], d[2]));
	}
	playerBody.quaternion.setFromEuler(Math.PI * 0.5, 0, 0);
	var playerMesh = new three.Object3D();
	// decorateMeshWithBodyTemps(playerMesh, playerBody);
	var handPivot = new three.Object3D();
	playerMesh.add(handPivot);
	handPivot.position.set(0.4, -0.5, -0.45);
	handPivot.rotation.set(Math.PI * 0.5, 0, 0);

	playerBody.player = this;
	playerBody.interactiveObject = {
		type: "player",
		object: this
	};



	var result = new CANNON.RaycastResult();
	var raycastOptions = {
		collisionFilterMask: CollisionLayers.ENVIRONMENT
	};
	var rayFrom = playerBody.position;
	var rayTo = playerBody.position.clone();

	this.onPointerDown = onPointerDown.bind(this);
	this.onPointerUp = onPointerUp.bind(this);

	pointers.onPointerDownSignal.add(this.onPointerDown);
	pointers.onPointerUpSignal.add(this.onPointerUp);

	this.yUp = true;
	this.keyboard = keyboard;
	this.camera = camera;
	this.fog = scene.fog;
	this.scene = scene;
	this.mesh = playerMesh;
	this.body = playerBody;
	this.bodySphereRecipe = bodySphereRecipe;

	this.pointers = pointers;

	this.result = result;
	this.raycastOptions = raycastOptions;
	this.rayFrom = rayFrom;
	this.rayTo = rayTo;
	this.fpsController = inputManager.fpsController;
	this.onPlayerSizeChangedSignal = onPlayerSizeChangedSignal;

	this.tools = tools;

	this.onDestroy = onDestroy.bind(this);
	this.onUpdateSim = onUpdateSim.bind(this);
	this.onSimPostStep = onSimPostStep.bind(this);
	this.onEnterFrame = onEnterFrame.bind(this);
	this.onPlayerBodyCollision = onPlayerBodyCollision.bind(this);
	this.addTool = addTool.bind(this);
	this.fog.near = this.camera.near;
	this.fog.far = this.camera.far;
	this.firstPortalOverlap = true;

	var user = null;
	Object.defineProperty(this, "user", {
		set: function(value) {
			user = value;
			if(user) {
				user.mesh.add(handPivot);
			} else {
				playerMesh.add(handPivot);
			}
		},
		get: function() {
			return user;
		}
	});

	var world = null;
	Object.defineProperty(this, "world", {
		set: function(value) {
			if(world) {
				world.physics.removeEventListener("postStep", this.onSimPostStep);
			}
			world = value;
			if(world) {
				world.physics.addEventListener("postStep", this.onSimPostStep);
			}
		},
		get: function() {
			return world;
		}
	});
	playerBody.addEventListener("collide", this.onPlayerBodyCollision);
}

function onSimPostStep() {
	if(this.user) {
		this.user.body.position.copy(this.body.position);
	}
}

function onPlayerBodyCollision(collision) {
	if(collision.target == this.body && collision.body.interactiveObject != null) {
		var interactiveObject = collision.body.interactiveObject;
		if(interactiveObject.type == "tool") {
			this.world.remove(interactiveObject.object, this.addTool.bind(this, interactiveObject.object));
		}
	}
}

function onDestroy() {
	this.pointers.onPointerDownSignal.remove(this.onPointerDown);
	this.pointers.onPointerUpSignal.remove(this.onPointerUp);
	this.world = null;
}

function onEnterFrame(timeScale) {
	var sizeChanged;
	if(this.keyboard.isPressed("openbracket")) {
		sizeChanged = true;
		this.sizeSpeed -= sizeSpeedStep;
	}
	if(this.keyboard.isPressed("closebraket")) {
		sizeChanged = true;
		this.sizeSpeed += sizeSpeedStep;
	}
	if(!sizeChanged) {
		this.sizeSpeed = 0;
	}
	if(sizeChanged) {
		var playerSize = this.playerSize;
		playerSize *= (1 + this.sizeSpeed);
		playerSize = clamp(playerSize, 0.00001, 40);
		this.fpsController.movementSpeed = 0.1 * playerSize;
		this.pointLight.distance = playerSize;
		// this.fog.near = this.camera.near = playerSize * 0.001;
		this.fog.far = playerSize * 40;
		// this.camera.far = this.fog.far + 0.1;
		// this.camera.updateProjectionMatrix();
		this.onPlayerSizeChangedSignal.dispatch(playerSize);
		for(var i = 0; i < this.bodySphereRecipe.length; i++) { 
			var d = this.bodySphereRecipe[i];
			this.body.shapes[i].radius = d[3] * playerSize;
			this.body.shapeOffsets[i].set(d[0] * playerSize, d[1] * playerSize, d[2] * playerSize);
		}
		this.body.mass = 50 * Math.pow(playerSize, 3);
		this.body.updateMassProperties();
		this.playerSize = playerSize;
	}
	if(this.keyboard.consumePressed("dash")) {
		if(!this.activeTool) return;
		this.activeTool = this.tools.prev(this.activeTool);
	}
	if(this.keyboard.consumePressed("equals")) {
		if(!this.activeTool) return;
		this.activeTool = this.tools.next(this.activeTool);
	}

	if(this.activeTool && this.activeTool.onEnterFrame) {
		this.activeTool.onEnterFrame(timeScale);
	}
}

function onUpdateSim() {
	var playerBody = this.body;
	playerBody.position.copy(this.user.body.position);
	if(this.keyboard.isPressed("space")) {
		this.rayTo.copy(this.rayFrom);
		this.rayTo.z -= 0.1 * this.playerSize;
		this.world.physics.raycastClosest(this.rayFrom, this.rayTo, this.raycastOptions, this.result);
		if(this.result.hasHit) {
			playerBody.applyImpulse(new CANNON.Vec3(0, 0, playerBody.mass * 10), playerBody.position);
		}
	}
}

function onPointerDown(x, y, id) {
	if(this.activeTool && this.activeTool.primaryFireStart) {
		var pos = this.user.crosshair.localToWorld(new three.Vector3());
		this.activeTool.primaryFireStart(pos, this.playerSize);
	}
}

function onPointerUp(x, y, id) {
	if(this.activeTool && this.activeTool.primaryFireEnd) {
		var pos = this.user.crosshair.localToWorld(new three.Vector3());
		this.activeTool.primaryFireEnd(pos, this.playerSize);
	}
}

function addTool(tool) {
	var added = this.tools.pushUnique(tool);
	if(added) {
		this.activeTool = tool;
	}
	return added;
}

module.exports = SimpleHominidBody;